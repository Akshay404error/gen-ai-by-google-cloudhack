import os
import re
from typing import List, Dict

from pydantic import BaseModel, Field

try:
    from langchain_groq import ChatGroq  # optional
    _has_groq = True
except Exception:
    _has_groq = False


DOMAIN_PROMPTS = {
    "general": "Generate comprehensive test cases for general software functionality.",
    "embedded": "Generate test cases for embedded systems and hardware interfaces.",
    "thermal": "Generate test cases for thermal monitoring and management systems.",
    "safety": "Generate test cases for safety-critical systems."
}

TECHNICAL_PATTERNS = {
    "thermal": ["thermal", "temperature", "sensor", "zone", "Â°C", "millidegrees", "BPMP", "SOC_THERM"],
    "embedded": ["embedded", "hardware", "driver", "firmware", "real-time", "RTOS", "register"],
    "safety": ["safety", "critical", "fault", "recovery", "redundancy", "ISO26262", "ASIL"],
    "general": ["user", "interface", "business", "application", "web", "mobile"],
}


def detect_domain(user_story: str) -> str:
    s = (user_story or "").lower()
    for domain, patterns in TECHNICAL_PATTERNS.items():
        if any(p.lower() in s for p in patterns):
            return domain
    return "general"


def _normalize_steps(steps):
    if isinstance(steps, list):
        return [str(x).strip() for x in steps if str(x).strip()]
    if isinstance(steps, str):
        parts = [s.strip(" -\t") for s in re.split(r"\n|\r|\d+\.|\- ", steps) if s and s.strip()]
        return parts
    return []


def generate_mock_test_cases(user_story: str, domain: str = "general", count: int = 3) -> List[Dict]:
    if domain == "thermal":
        base = [
            {
                "test_title": "Verify successful temperature query for thermal zone",
                "description": "Test temperature retrieval for supported thermal zones",
                "preconditions": "Thermal zone supported, system in normal state",
                "test_steps": [
                    "Open connection to thermal zone",
                    "Query temperature",
                    "Validate response",
                ],
                "test_data": "Valid thermal zone name, expected temperature range",
                "expected_result": "API returns success with valid temperature values",
                "priority": "High",
                "test_type": "Functional",
                "domain": "thermal",
                "comments": "Validates core thermal monitoring functionality",
            },
            {
                "test_title": "Verify timestamp accuracy for temperature queries",
                "description": "Ensure timestamps recorded accurately",
                "preconditions": "System time synchronized",
                "test_steps": [
                    "Query temperature with timestamp",
                    "Compare with system time",
                    "Validate accuracy",
                ],
                "test_data": "System time reference",
                "expected_result": "Timestamp within acceptable tolerance",
                "priority": "Medium",
                "test_type": "Functional",
                "domain": "thermal",
                "comments": "Ensures temporal data integrity",
            },
            {
                "test_title": "Verify error handling for invalid thermal zones",
                "description": "Proper error handling for non-existent zones",
                "preconditions": "System initialized",
                "test_steps": [
                    "Query invalid thermal zone",
                    "Verify error response",
                    "Check error codes",
                ],
                "test_data": "Invalid zone names, malformed requests",
                "expected_result": "Proper error message and code returned",
                "priority": "High",
                "test_type": "Negative",
                "domain": "thermal",
                "comments": "Tests system robustness",
            },
        ]
        data = base * ((count + 2) // 3)
        data = data[:count]
    else:
        data = []
        for i in range(count):
            data.append({
                "test_title": f"Functional Test - {user_story[:25]}...",
                "description": f"Validate main functionality: {user_story}",
                "preconditions": "System is available and test environment ready",
                "test_steps": ["Navigate to feature", "Perform primary action", "Verify results"],
                "test_data": "Valid input data, typical usage scenario",
                "expected_result": "Function works as expected without errors",
                "priority": "High" if i == 0 else "Medium",
                "test_type": "Functional" if i != 1 else "Negative",
                "domain": domain,
                "comments": "Generated by mock generator",
            })
    # number them
    for idx, tc in enumerate(data, start=1):
        tc["test_case_id"] = idx
    return data


def generate_ai_test_cases(user_story: str, domain: str, count: int = 3, *, model: str = "llama-3.1-8b-instant", temperature: float = 0.2, max_tokens: int = 2000, extra_instructions: str = "") -> List[Dict]:
    if not _has_groq or not os.getenv("GROQ_API_KEY"):
        return generate_mock_test_cases(user_story, domain, count)
    try:
        llm = ChatGroq(model=model, temperature=temperature, max_tokens=max_tokens)
        prompt = (
            f"{DOMAIN_PROMPTS.get(domain, DOMAIN_PROMPTS['general'])}\n"
            f"User Story: {user_story}\n"
            f"Generate {count} test cases as a JSON array with keys: test_title, description, preconditions, test_steps (array), test_data, expected_result, priority, test_type, domain, comments."
            f"Additional instructions: {extra_instructions}"
        )
        res = llm.invoke(prompt)
        # Try to parse JSON in the text
        import json
        text = getattr(res, "content", None) or str(res)
        # Find JSON array in text
        start = text.find("[")
        end = text.rfind("]")
        if start != -1 and end != -1 and end > start:
            data = json.loads(text[start:end+1])
        else:
            data = []
        if not isinstance(data, list):
            data = []
        for i, tc in enumerate(data, start=1):
            tc["test_case_id"] = i
            tc["test_steps"] = _normalize_steps(tc.get("test_steps"))
            tc["domain"] = domain
        if not data:
            data = generate_mock_test_cases(user_story, domain, count)
        return data[:count]
    except Exception:
        return generate_mock_test_cases(user_story, domain, count)
